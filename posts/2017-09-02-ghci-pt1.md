---
title: GHCi - Parte 1
date: 2017-09-02 15:54:56
tags: ghci, es, haskell
description: "Parte 1: Funcionamiento básico de GHCi"
---

# Nota inicial:
Esta es una serie de tutoriales dedicados a explorar el interprete de
[Glasgow Haskell Compiler o GHC](https://www.haskell.org/ghc/). Bueno, ¿y por qué
no empezar con algo básico de Haskell? Principalmente, porque ya conozco lo básico
del lenguaje y porque estoy seguro que pueden encontrar esa información fácilmente
buscándola en google. Por ejemplo, [aprende haskell por el bien de todos](http://aprendehaskell.es/),
puedes revisar los blog posts de [Silly Bytes](http://sillybytes.net/2016/06/aprende-haskell-rapido-y-dificil_29.html),
y también puedes encontrar varios tutoriales en [YouTube](https://www.youtube.com/results?search_query=introduccion+a+haskell).
Y eso solo en Español, en Inglés puedes miles de recursos. Si deseas aprender,
¿qué esperas? ¿qué inventen algo como en Matrix?

![**Imagen 1. Neo Aprende Haskell**][1]

# Requisitos:
Para este blog post utilicé lo siguiente:
- [stack](https://docs.haskellstack.org/en/stable/README/)
- El [lts-8.2](https://www.stackage.org/lts-8.2)
- Una versión de GHC instalada con stack (`stack setup`)

# GHCi
GHCi (Glasgow Haskell Compiler Interactive) es el interprete interactivo o
[*REPL]*(https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) 
en el cual se puede leer (Read) expresiones, evaluarlas (Eval), imprimir un 
resultado ante el usuario (Print) y repetir este proceso (Loop). En este blog
post hablaré sobre las funciones básicas que se pueden realizar con GHCi.

# Iniciar GHCi
Simplemente, desde una terminar en la cual tengas instalado `stack` ejecuta `stack ghci`

```shell
$ stack ghci
Configuring GHCi with the following packages:
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /tmp/ghci6756/ghci-script
Prelude>
```

Y para comenzar, solicitemos algo de ayuda, ejecutando la siguiente sentencia:

```shell
Prelude> :?
 Commands available from the prompt:

   <statement>                 evaluate/run <statement>
   :                           repeat last command
   :{\n ..lines.. \n:}\n       multiline command
   :add [*]<module> ...        add module(s) to the current target set
   :browse[!] [[*]<mod>]       display the names defined by module <mod>
                               (!: more details; *: all top-level names)
   :cd <dir>                   change directory to <dir>
   :cmd <expr>                 run the commands returned by <expr>::IO String
   ...

   UNA GRAN DESCRIPCIÓN DESPUÉS...

   ...

Prelude>
```

[1]: /images/ghci-pt1/neo-ya-se-haskell.jpg
