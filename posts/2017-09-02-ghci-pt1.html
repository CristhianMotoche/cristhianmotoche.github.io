<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="description" content="A blog page for people who is interested in programming.">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CAMM Blog</title>
    <link rel="icon" type="image/png" href="../images/devi.png">
    <link href="../css/default.css" rel="stylesheet">
    <meta name="google-site-verification" content="ZE7UdJw8EgIGYT1wlPQ1IDRaqOa9IseKmfw4ufHxEAk" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body class="body">
    <div class="body__container">
      <div class="logo">
        <h1 class="logo__title">
          <a class="logo__link" href="../">Camm Blog Page</a>
        </h1>
      </div>
      <nav class="navbar">
        <ul class="nav-list">
          <li class="nav-list__item">
            <a class="nav-list__link" href="../">Home</a>
          </li>
          <li class="nav-list__item">
            <a class="nav-list__link" href="../contact.html">About</a>
          </li>
          <li class="nav-list__item">
            <a class="nav-list__link" href="../archive.html">Archive</a>
          </li>
        </ul>
      </nav>
      <div class="content">
        <h1 class="content__title">GHCi - Parte 1</h1>
        <div class="content_body">
          <link href="../css/hk-pyg.css" rel="stylesheet">
<link href="../css/tables.css" rel="stylesheet">
<div class="info">
    Posted on September  2, 2017
    
</div>
<div class="info">
    
    Tags: <a href="../tags/ghci.html">ghci</a>, <a href="../tags/es.html">es</a>, <a href="../tags/haskell.html">haskell</a>
    
</div>

<h2 id="nota-inicial">Nota inicial:</h2>
<p>Esta es una serie de tutoriales dedicados a explorar el interprete de <a href="https://www.haskell.org/ghc/">Glasgow Haskell Compiler o GHC</a>. Bueno, ¿y por qué no empezar con algo básico de Haskell? Principalmente, porque ya conozco lo básico del lenguaje y estoy seguro que pueden encontrar esa información fácilmente buscándola en Internet. Por ejemplo: <a href="http://aprendehaskell.es/">Aprende haskell por el bien de todos</a>, los blog posts de <a href="http://sillybytes.net/2016/06/aprende-haskell-rapido-y-dificil_29.html">Silly Bytes</a>, varios video tutoriales en <a href="https://www.youtube.com/results?search_query=introduccion+a+haskell">YouTube</a>. Y eso solo en Español, en Inglés encontrarás miles de recursos. No esperes a que creen una máquina como la de Matrix.</p>
<figure>
<img src="../images/ghci-pt1/neo-ya-se-haskell.jpg" alt="Imagen 1. Neo Aprende Haskell" /><figcaption><strong>Imagen 1. Neo Aprende Haskell</strong></figcaption>
</figure>
<h1 id="requisitos">1. Requisitos:</h1>
<p>Para este blog post utilicé lo siguiente:</p>
<ul>
<li><a href="https://docs.haskellstack.org/en/stable/README/">stack</a></li>
<li>Stack resolver: <a href="https://www.stackage.org/lts-9.2">lts-9.2</a></li>
<li>GHC-8.0.2 instalado con stack (<code>stack setup</code>)</li>
</ul>
<h1 id="ghci">2. GHCi</h1>
<p>GHCi (Glasgow Haskell Compiler Interactive) es el interprete interactivo o <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> para Haskell. En el cual se pueden leer (Read) expresiones, evaluarlas (Eval), imprimir el resultado en pantalla (Print) y repetir estos pasos nuevamente (Loop) mientras se desee. En este blog post revisaré algunas funciones básicas que se pueden realizar con GHCi.</p>
<h1 id="iniciar-ghci">3. Iniciar GHCi</h1>
<p>Desde una terminal, en la cual tengas instalado <code>stack</code>, ejecuta <code>stack ghci</code>. Utilicé <a href="https://docs.haskellstack.org/en/stable/ghci/">stack ghci</a>, que carga los módulos de librerías y ejecutables del proyecto de Haskell en el cual me encuentre. Además puedo añadir algunas banderas para extender los componentes que se cargan, por ejemplo: <code>--test</code>, y <code>--bench</code>. Y otros flags, de los cuales podría hacer un blog posts pequeño en algún momento (atento con eso).</p>
<pre class="shell"><code>$ stack ghci
Configuring GHCi with the following packages:
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /tmp/ghci6756/ghci-script
Prelude&gt;</code></pre>
<p>Y para comenzar, solicitemos algo de ayuda, ejecutando el siguiente comando:</p>
<pre class="shell"><code>Prelude&gt; :?
 Commands available from the prompt:

   &lt;statement&gt;                 evaluate/run &lt;statement&gt;
   :                           repeat last command
   :{\n ..lines.. \n:}\n       multiline command
   :add [*]&lt;module&gt; ...        add module(s) to the current target set
   :browse[!] [[*]&lt;mod&gt;]       display the names defined by module &lt;mod&gt;
                               (!: more details; *: all top-level names)
   :cd &lt;dir&gt;                   change directory to &lt;dir&gt;
   :cmd &lt;expr&gt;                 run the commands returned by &lt;expr&gt;::IO String
   ...

   UNA LARGA DESCRIPCIÓN DESPUÉS...

   ...

Prelude&gt;</code></pre>
<p>Como se puede observar, la cantidad de información de ayuda es amplia. En este blog post mostraré la parte más básica de GHCi.</p>
<h2 id="lo-básico">4. Lo Básico</h2>
<h3 id="evaluación-de-expresiones">4.1 Evaluación de expresiones</h3>
<p>GHCi es un interprete o repl para Haskell y como tal lee expresiones, las evalua, imprime el resultado de la evaluación y repite este proceso. Por ejemplo:</p>
<pre><code>Prelude&gt; 3 + 4
7
Prelude&gt;</code></pre>
<p>En el primer punto lee la expresión <code>3 + 4</code>, luego la evalua, es decir, internamente aplica la suma entre 3 y 4. Luego imprime el resultado, que es <code>7</code>, y vuelve a esperar que el usuario ingrese más expresiones.</p>
<pre><code>Prelude&gt; let x = 3
Prelude&gt; let y = 4
Prelude&gt; let z = x + y
Prelude&gt; z
7</code></pre>
<p>En el ejemplo anterior simplemente definimos <code>x</code> como 3 y <code>y</code> como 4 y <code>z</code> como el resultado de la suma de ambas cantidades. Y por supuesto, también se puede definir funciones propias, estas también son expresiones. Recuerda que en Haskell todo se maneja por <a href="http://lambda-the-ultimate.org/node/1044#comment-10878">expresiones, más no por sentencias.</a> Como tal vez se haya visto en lenguaje imperativos.</p>
<pre><code>Prelude&gt; let myFunc x y = x + y
Prelude&gt; myFunc 3 4
7</code></pre>
<h3 id="comandos-básicos-del-prompt">4.2 Comandos básicos del prompt</h3>
<p>Los siguientes comandos los voy a copiar y traducir directamente de <a href="http://dev.stephendiehl.com/hask/#ghci">What I Wish I Knew When Learning Haskell</a> y extenderé un poco la lista con algunos comandos faltantes:</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Comando</th>
<th>Atajo</th>
<th style="text-align: left;">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>:reload</code></td>
<td><code>:r</code> | Recar</td>
<td style="text-align: left;">Recargar código</td>
</tr>
<tr class="even">
<td><code>:type</code> |<code>:t</code></td>
<td><code>:t</code> |</td>
<td style="text-align: left;">Inspeccionar un tipo</td>
</tr>
<tr class="odd">
<td><code>:kind</code> |<code>:k</code></td>
<td><code>:k</code> |</td>
<td style="text-align: left;">Inspeccionar un kind</td>
</tr>
<tr class="even">
<td><code>:info</code> |<code>:i</code></td>
<td><code>:i</code> |</td>
<td style="text-align: left;">Información adicional</td>
</tr>
<tr class="odd">
<td><code>:print</code> |<code>:p</code></td>
<td><code>:p</code> |</td>
<td style="text-align: left;">Imprimir una expresión</td>
</tr>
<tr class="even">
<td><code>:edit</code> |<code>:e</code></td>
<td><code>:e</code> |</td>
<td style="text-align: left;">Cargar un archivo en el editor del sistema</td>
</tr>
<tr class="odd">
<td><code>:load</code> |<code>:l</code></td>
<td><code>:l</code> |</td>
<td style="text-align: left;">Asignar el módulo Main en el REPL</td>
</tr>
<tr class="even">
<td><code>:add</code></td>
<td><code>:ad</code> | Carg</td>
<td style="text-align: left;">Cargar un archivo en el namespace del REPL</td>
</tr>
<tr class="odd">
<td><code>:browse</code></td>
<td><code>:bro</code></td>
<td style="text-align: left;">Navegar por todos los símbolos del REPL</td>
</tr>
<tr class="even">
<td><code>:cd</code></td>
<td><code>:cd</code></td>
<td style="text-align: left;">Cambiar de directorio (provoca que se liberen los módulos cargados en REPL)</td>
</tr>
</tbody>
</table>
<p>A contiación, se crea un proyecto simple con <code>stack</code> para jugar un poco con GHCi.</p>
<pre><code>$ stack new ghci-test
...

$ stack ghci
ghci-test-0.1.0.0: initial-build-steps (lib + exe)
The following GHC options are incompatible with GHCi and have not been passed to it: -threaded
Configuring GHCi with the following packages: ghci-test
Using main module: 1. Package `ghci-test' component exe:ghci-test-exe with main-is file: /tmp/ghci-test/app/Main.hs
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling Lib              ( /tmp/ghci-test/src/Lib.hs, interpreted )
Ok, modules loaded: Lib.
[2 of 2] Compiling Main             ( /tmp/ghci-test/app/Main.hs, interpreted )
Ok, modules loaded: Lib, Main.
Loaded GHCi configuration from /tmp/ghci10117/ghci-script
*Main Lib&gt;</code></pre>
<p>El proyecto tiene un componente principal que se encuentra en <code>app/Main.hs</code> y es un modulo de Haskell que está definido como principal en el ejecutable del archivo <code>ghci-test.cabal</code>. Ahora sí, a jugar un poco:</p>
<pre><code>*Main Lib&gt; -- Podemos ejecutar las funciones definidas en nuestra librería
*Main Lib&gt; someFunc
someFunc
*Main Lib&gt; -- En este caso, solo era una función que imprime &quot;someFunc&quot;
*Main Lib&gt; -- También podemos ejecutar la función principal (main)
*Main Lib&gt; main
someFunc
*Main Lib&gt; -- Que en este caso solo llama a someFunc (lol)</code></pre>
<p>En las siguientes expresiones se está inspeccionando el tipo de cada una de ellas.</p>
<pre><code>*Main Lib&gt; :t &quot;Hello world!&quot;
&quot;Hello world!&quot; :: [Char]
*Main Lib&gt; :t someFunc
someFunc :: IO ()
*Main Lib&gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></pre>
<p>Veamos algunos kinds:</p>
<pre><code>*Main Lib&gt; :kind Maybe
Maybe :: * -&gt; *
*Main Lib&gt; :kind Maybe Int
Maybe Int :: *
*Main Lib&gt; :kind Either
Either :: * -&gt; * -&gt; *</code></pre>
<p>Yeah! Ahora algo de información adicional.</p>
<pre><code>*Main Lib&gt; :info Maybe
data Maybe a = Nothing | Just a         -- Defined in ‘GHC.Base’
instance Eq a =&gt; Eq (Maybe a) -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Ord a =&gt; Ord (Maybe a) -- Defined in ‘GHC.Base’
instance Read a =&gt; Read (Maybe a) -- Defined in ‘GHC.Read’
instance Show a =&gt; Show (Maybe a) -- Defined in ‘GHC.Show’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Traversable Maybe -- Defined in ‘Data.Traversable’
instance Monoid a =&gt; Monoid (Maybe a) -- Defined in ‘GHC.Base’

*Main Lib&gt; :info Functor
class Functor (f :: * -&gt; *) where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
  (&lt;$) :: a -&gt; f b -&gt; f a
  {-# MINIMAL fmap #-}
        -- Defined in ‘GHC.Base’
instance Functor (Either a) -- Defined in ‘Data.Either’
instance Functor [] -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Functor ((-&gt;) r) -- Defined in ‘GHC.Base’
instance Functor ((,) a) -- Defined in ‘GHC.Base’

*Main Lib&gt; :i someFunc
someFunc :: IO ()       -- Defined at /tmp/ghci-test/src/Lib.hs:6:1</code></pre>
<p>Podemos ver que al utilizar <code>:info</code> (o <code>:i</code>) sobre un tipo de datos, nos da información sobre sus constructores y las instancias que están cargadas en el REPL actualmente. Si lo hacemos sobre una clase de tipos (<code>type class</code>) podremos observar el <code>kind</code> del tipo que espera y las funciones que define la clase y sus definiciones mínimas, las instancias de esa clase y el módulo en el cual están definidas. ¡Vaya que es información útil! Y al hacerlo sobre expresiones (e.g. funciones) nos mostrará el lugar en el cual están definidos. ¡Ojo!, las instancias que se muestran <strong>están siendo filtradas</strong>, para mostrar todas se debe utilizar <code>:info!</code> (no existe atajo para esta opción).</p>
<p>Y con <code>:browse</code> se puede ver las expresiones definidas en un módulo.</p>
<pre><code>*Main Lib&gt; :browse Lib
someFunc :: IO ()</code></pre>
<p>En este caso solo se ve <code>someFunc</code>. Pero también se podrían ver tipos de datos (y sus constructores), clases de tipos, etc.</p>
<p>En otro blog post hablaré sobre <code>:load</code>, <code>:add</code>, <code>:show</code> y <code>:set</code>. Ya que me gustaría hablar sobre la forma en la cual se cargan los módulos, el namespace de ghci, las distintas opciones que nos proporciona <code>:show</code>, y como <code>:set</code> nos permite crear nuestros propios comandos. Bueno, hasta ahora he mostrado algunos de los comandos que vienen por defecto en el repl. Ojalá te haya servido de algo, tanto como a mi.</p>
<p>Comentarios, sugerencias, preguntas, etc. Son bienvenidos. <code>&gt;:-D</code> ByE!</p>

<div id="disqus_thread"></div>
<script>
/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
 */
/*
   var disqus_config = function () {
   this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
   this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
   };
 */
(function() {  // DON'T EDIT BELOW THIS LINE
 var d = document, s = d.createElement('script');

 s.src = '//cristhianmotochegithubio.disqus.com/embed.js';

 s.setAttribute('data-timestamp', +new Date());
 (d.head || d.body).appendChild(s);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

        </div>
      </div>
      <footer class="footer">
        <p class="footer__hakyll">Site proudly generated by: <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
        <a class="footer__license" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">CAMM Blog</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Cristhian Alberto Motoche Macas</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
      </footer>
    </div>
    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-86039843-1', 'auto');
    ga('send', 'pageview');
    </script>
  </body>
</html>
